/**
 *
 *                                 Apache License
 *                           Version 2.0, January 2004
 *                        http://www.apache.org/licenses/
 *
 *   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *   1. Definitions.
 *
 *      "License" shall mean the terms and conditions for use, reproduction,
 *      and distribution as defined by Sections 1 through 9 of this document.
 *
 *      "Licensor" shall mean the copyright owner or entity authorized by
 *      the copyright owner that is granting the License.
 *
 *      "Legal Entity" shall mean the union of the acting entity and all
 *      other entities that control, are controlled by, or are under common
 *      control with that entity. For the purposes of this definition,
 *      "control" means (i) the power, direct or indirect, to cause the
 *      direction or management of such entity, whether by contract or
 *      otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *      outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *      "You" (or "Your") shall mean an individual or Legal Entity
 *      exercising permissions granted by this License.
 *
 *      "Source" form shall mean the preferred form for making modifications,
 *      including but not limited to software source code, documentation
 *      source, and configuration files.
 *
 *      "Object" form shall mean any form resulting from mechanical
 *      transformation or translation of a Source form, including but
 *      not limited to compiled object code, generated documentation,
 *      and conversions to other media types.
 *
 *      "Work" shall mean the work of authorship, whether in Source or
 *      Object form, made available under the License, as indicated by a
 *      copyright notice that is included in or attached to the work
 *      (an example is provided in the Appendix below).
 *
 *      "Derivative Works" shall mean any work, whether in Source or Object
 *      form, that is based on (or derived from) the Work and for which the
 *      editorial revisions, annotations, elaborations, or other modifications
 *      represent, as a whole, an original work of authorship. For the purposes
 *      of this License, Derivative Works shall not include works that remain
 *      separable from, or merely link (or bind by name) to the interfaces of,
 *      the Work and Derivative Works thereof.
 *
 *      "Contribution" shall mean any work of authorship, including
 *      the original version of the Work and any modifications or additions
 *      to that Work or Derivative Works thereof, that is intentionally
 *      submitted to Licensor for inclusion in the Work by the copyright owner
 *      or by an individual or Legal Entity authorized to submit on behalf of
 *      the copyright owner. For the purposes of this definition, "submitted"
 *      means any form of electronic, verbal, or written communication sent
 *      to the Licensor or its representatives, including but not limited to
 *      communication on electronic mailing lists, source code control systems,
 *      and issue tracking systems that are managed by, or on behalf of, the
 *      Licensor for the purpose of discussing and improving the Work, but
 *      excluding communication that is conspicuously marked or otherwise
 *      designated in writing by the copyright owner as "Not a Contribution."
 *
 *      "Contributor" shall mean Licensor and any individual or Legal Entity
 *      on behalf of whom a Contribution has been received by Licensor and
 *      subsequently incorporated within the Work.
 *
 *   2. Grant of Copyright License. Subject to the terms and conditions of
 *      this License, each Contributor hereby grants to You a perpetual,
 *      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *      copyright license to reproduce, prepare Derivative Works of,
 *      publicly display, publicly perform, sublicense, and distribute the
 *      Work and such Derivative Works in Source or Object form.
 *
 *   3. Grant of Patent License. Subject to the terms and conditions of
 *      this License, each Contributor hereby grants to You a perpetual,
 *      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *      (except as stated in this section) patent license to make, have made,
 *      use, offer to sell, sell, import, and otherwise transfer the Work,
 *      where such license applies only to those patent claims licensable
 *      by such Contributor that are necessarily infringed by their
 *      Contribution(s) alone or by combination of their Contribution(s)
 *      with the Work to which such Contribution(s) was submitted. If You
 *      institute patent litigation against any entity (including a
 *      cross-claim or counterclaim in a lawsuit) alleging that the Work
 *      or a Contribution incorporated within the Work constitutes direct
 *      or contributory patent infringement, then any patent licenses
 *      granted to You under this License for that Work shall terminate
 *      as of the date such litigation is filed.
 *
 *   4. Redistribution. You may reproduce and distribute copies of the
 *      Work or Derivative Works thereof in any medium, with or without
 *      modifications, and in Source or Object form, provided that You
 *      meet the following conditions:
 *
 *      (a) You must give any other recipients of the Work or
 *          Derivative Works a copy of this License; and
 *
 *      (b) You must cause any modified files to carry prominent notices
 *          stating that You changed the files; and
 *
 *      (c) You must retain, in the Source form of any Derivative Works
 *          that You distribute, all copyright, patent, trademark, and
 *          attribution notices from the Source form of the Work,
 *          excluding those notices that do not pertain to any part of
 *          the Derivative Works; and
 *
 *      (d) If the Work includes a "NOTICE" text file as part of its
 *          distribution, then any Derivative Works that You distribute must
 *          include a readable copy of the attribution notices contained
 *          within such NOTICE file, excluding those notices that do not
 *          pertain to any part of the Derivative Works, in at least one
 *          of the following places: within a NOTICE text file distributed
 *          as part of the Derivative Works; within the Source form or
 *          documentation, if provided along with the Derivative Works; or,
 *          within a display generated by the Derivative Works, if and
 *          wherever such third-party notices normally appear. The contents
 *          of the NOTICE file are for informational purposes only and
 *          do not modify the License. You may add Your own attribution
 *          notices within Derivative Works that You distribute, alongside
 *          or as an addendum to the NOTICE text from the Work, provided
 *          that such additional attribution notices cannot be construed
 *          as modifying the License.
 *
 *      You may add Your own copyright statement to Your modifications and
 *      may provide additional or different license terms and conditions
 *      for use, reproduction, or distribution of Your modifications, or
 *      for any such Derivative Works as a whole, provided Your use,
 *      reproduction, and distribution of the Work otherwise complies with
 *      the conditions stated in this License.
 *
 *   5. Submission of Contributions. Unless You explicitly state otherwise,
 *      any Contribution intentionally submitted for inclusion in the Work
 *      by You to the Licensor shall be under the terms and conditions of
 *      this License, without any additional terms or conditions.
 *      Notwithstanding the above, nothing herein shall supersede or modify
 *      the terms of any separate license agreement you may have executed
 *      with Licensor regarding such Contributions.
 *
 *   6. Trademarks. This License does not grant permission to use the trade
 *      names, trademarks, service marks, or product names of the Licensor,
 *      except as required for reasonable and customary use in describing the
 *      origin of the Work and reproducing the content of the NOTICE file.
 *
 *   7. Disclaimer of Warranty. Unless required by applicable law or
 *      agreed to in writing, Licensor provides the Work (and each
 *      Contributor provides its Contributions) on an "AS IS" BASIS,
 *      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *      implied, including, without limitation, any warranties or conditions
 *      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *      PARTICULAR PURPOSE. You are solely responsible for determining the
 *      appropriateness of using or redistributing the Work and assume any
 *      risks associated with Your exercise of permissions under this License.
 *
 *   8. Limitation of Liability. In no event and under no legal theory,
 *      whether in tort (including negligence), contract, or otherwise,
 *      unless required by applicable law (such as deliberate and grossly
 *      negligent acts) or agreed to in writing, shall any Contributor be
 *      liable to You for damages, including any direct, indirect, special,
 *      incidental, or consequential damages of any character arising as a
 *      result of this License or out of the use or inability to use the
 *      Work (including but not limited to damages for loss of goodwill,
 *      work stoppage, computer failure or malfunction, or any and all
 *      other commercial damages or losses), even if such Contributor
 *      has been advised of the possibility of such damages.
 *
 *   9. Accepting Warranty or Additional Liability. While redistributing
 *      the Work or Derivative Works thereof, You may choose to offer,
 *      and charge a fee for, acceptance of support, warranty, indemnity,
 *      or other liability obligations and/or rights consistent with this
 *      License. However, in accepting such obligations, You may act only
 *      on Your own behalf and on Your sole responsibility, not on behalf
 *      of any other Contributor, and only if You agree to indemnify,
 *      defend, and hold each Contributor harmless for any liability
 *      incurred by, or claims asserted against, such Contributor by reason
 *      of your accepting any such warranty or additional liability.
 *
 *   END OF TERMS AND CONDITIONS
 *
 *   APPENDIX: How to apply the Apache License to your work.
 *
 *      To apply the Apache License to your work, attach the following
 *      boilerplate notice, with the fields enclosed by brackets "[]"
 *      replaced with your own identifying information. (Don't include
 *      the brackets!)  The text should be enclosed in the appropriate
 *      comment syntax for the file format. We also recommend that a
 *      file or class name and description of purpose be included on the
 *      same "printed page" as the copyright notice for easier
 *      identification within third-party archives.
 *
 *   Copyright 2018 rnkrsoft
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */
package com.rnkrsoft.platform.client;


import com.rnkrsoft.com.google.gson.Gson;
import com.rnkrsoft.com.google.gson.GsonBuilder;
import com.rnkrsoft.config.AbstractConfigProvider;
import com.rnkrsoft.platform.client.configure.RemoteConfigureProvider;
import com.rnkrsoft.platform.client.connector.InterfaceConnector;
import com.rnkrsoft.platform.client.exception.InitException;
import com.rnkrsoft.platform.client.exception.LocationProviderNotFoundException;
import com.rnkrsoft.platform.client.logger.Logger;
import com.rnkrsoft.platform.client.logger.LoggerFactory;
import com.rnkrsoft.platform.client.logger.LoggerLevel;
import com.rnkrsoft.platform.client.logger.file.LoggerConstant;
import com.rnkrsoft.platform.client.proxy.ServiceProxyFactory;
import com.rnkrsoft.platform.client.scanner.ClassScanner;
import com.rnkrsoft.platform.client.scanner.MetadataClassPathScanner;
import com.rnkrsoft.platform.protocol.ApiResponse;
import com.rnkrsoft.platform.protocol.AsyncHandler;
import com.rnkrsoft.platform.protocol.enums.InterfaceRspCode;
import com.rnkrsoft.platform.protocol.service.*;
import com.rnkrsoft.platform.protocol.utils.JavaEnvironmentDetector;
import com.rnkrsoft.utils.StringUtils;
import lombok.Getter;
import lombok.Setter;

import javax.web.doc.annotation.ApidocService;
import java.lang.reflect.Constructor;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Created by rnkrsoft.com on 2019/1/17.
 * 服务工厂，用于获取本地服务接口包装的实例
 */
public final class ServiceFactory {
    static Logger log = LoggerFactory.getLogger(ServiceFactory.class);
    /**
     * 接口连接器
     */
    private InterfaceConnector interfaceConnector;
    /**
     * 定义信息注册中心
     */
    @Getter
    private final DefinitionRegister definitionRegister = new DefinitionRegister();
    /**
     * 元信息信息注册中心
     */
    @Getter
    private final MetadataRegister metadataRegister = new MetadataRegister();
    /**
     * 服务注册中心
     */
    @Getter
    private final ServiceRegister serviceRegister = new ServiceRegister();
    /**
     * 配置对象
     */
    @Getter
    private final ServiceConfigure serviceConfigure = new ServiceConfigure();
    /**
     * 定位信息提供者
     */
    private LocationProvider locationProvider;
    /**
     * 远程配置提供者
     */
    private ConfigureProvider configureProvider = new RemoteConfigureProvider();

    /**
     * 已注册的服务类
     */
    final List<Class> serviceClasses = new ArrayList<Class>();

    final Gson gson = new GsonBuilder().create();

    final AtomicBoolean init = new AtomicBoolean(false);

    @Setter
    long fetchConfigureIntervalSecond = 0L;

    @Setter
    long fetchMetadataIntervalSecond = 0L;

    final ScheduledExecutorService scheduleExecutor = Executors.newScheduledThreadPool(2);

    /**
     * 工厂类，不能实例化
     */
    private ServiceFactory() {
    }

    public boolean isInit() {
        return init.get();
    }

    /**
     * 配置日志
     *
     * @param logDir      日志目录
     * @param prefix      前缀
     * @param suffix      后缀
     * @param sout        标准输出
     * @param loggerLevel 日志级别
     */
    public static final void settingLogger(String logDir, String prefix, String suffix, boolean sout, LoggerLevel loggerLevel) {
        final Properties properties = new Properties();
        properties.setProperty(LoggerConstant.LOGGER_DIRECTORY, logDir);
        properties.setProperty(LoggerConstant.LOGGER_PREFIX, prefix);
        properties.setProperty(LoggerConstant.LOGGER_SUFFIX, suffix);
        properties.setProperty(LoggerConstant.LOGGER_SOUT, Boolean.toString(sout));
        properties.setProperty(LoggerConstant.LOGGER_LEVEL, loggerLevel.name());

        final Properties defaults = new Properties();
        LoggerFactory.setting(new AbstractConfigProvider() {
            @Override
            public void init(String configDir, int reloadInterval) {

            }

            @Override
            public void init(int reloadInterval) {

            }

            @Override
            public void reload() {

            }

            @Override
            public void save() {

            }

            public void param(String name, String value) {
                defaults.setProperty(name, value);
            }


            public <T> T getParam(String paramName, Class<T> paramClass) {
                Object value = null;
                if (!properties.containsKey(paramName)) {
                    value = defaults.getProperty(paramName);
                } else {
                    value = properties.getProperty(paramName);
                }
                return convert(value, paramClass);
            }
        });
    }

    /**
     * 设置配置中心
     *
     * @param ssl         是否启用HTTPS
     * @param host        主机地址
     * @param port        端口号
     * @param contextPath 上下文路径
     */
    public final void settingConfigure(boolean ssl, String host, int port, String contextPath) {
        log.info("set configure setting, {}://{}:{}/{}", ssl ? "https" : "http", host, port, contextPath);
        serviceConfigure.configSchema = ssl ? "https" : "http";
        serviceConfigure.configHost = host;
        serviceConfigure.configPort = port;
        serviceConfigure.configContextPath = contextPath;
    }

    /**
     * 设置失败后退回配置
     *
     * @param channel     通道号
     * @param ssl         是否启用HTTPS
     * @param host        主机地址
     * @param port        端口号
     * @param contextPath 上下文路径
     */
    public final void settingFallback(String channel, boolean ssl, String host, int port, String contextPath) {
        log.info("set fallback setting, {} --> {}://{}:{}/{}", channel, ssl ? "https" : "http", host, port, contextPath);
        serviceConfigure.settingFallback(channel, ssl, host, port, contextPath);
    }

    /**
     * 设置客户端固定密码
     *
     * @param password 密码
     */
    public final void setPassword(String password) {
        serviceConfigure.setPassword(password);
    }

    /**
     * 设置客户端秘钥向量
     *
     * @param keyVector 向量
     */
    public final void setKeyVector(String keyVector) {
        serviceConfigure.setKeyVector(keyVector);
    }

    /**
     * 设置APP版本号
     *
     * @param appVersion APP版本号
     */
    public final void setAppVersion(String appVersion) {
        serviceConfigure.setAppVersion(appVersion);
    }

    /**
     * 注册位置提供者
     *
     * @param locationProvider 位置提供者
     */
    public void registerLocationProvider(LocationProvider locationProvider) {
        this.locationProvider = locationProvider;
    }

    /**
     * 注册远程配置提供者
     *
     * @param configureProvider 配置提供者
     */
    public void registerConfigureProvider(ConfigureProvider configureProvider) {
        this.configureProvider = configureProvider;
    }

    boolean fetchRemoteConfigure(boolean silent, AsyncHandler asyncHandler) {
        if (configureProvider == null) {
            log.warn("未配置远程配置, 启用本地配置");
            LoggerFactory.level(LoggerLevel.TRACE);
            serviceConfigure.setLocalConfigure(true);
            serviceConfigure.channelAddresses.clear();
            for (String channel : serviceConfigure.getChannels()) {
                serviceConfigure.channelAddresses.clear();
                //如果回退配置不存在这个通道，则不处理
                if (serviceConfigure.fallbackChannelAddresses.containsKey(channel)) {
                    serviceConfigure.channelAddresses.put(channel, Arrays.asList(serviceConfigure.fallbackChannelAddresses.get(channel)));
                }
            }
            return true;
        } else {
            if (serviceConfigure.isAutoLocate()) {
                refreshLocation();
            }
            Configure configure = configureProvider.load(serviceConfigure.configSchema, serviceConfigure.configHost, serviceConfigure.configPort, serviceConfigure.configContextPath, serviceConfigure.getChannels(), serviceConfigure.getUic(), serviceConfigure.getDeviceType(), serviceConfigure.getAppVersion(), serviceConfigure.getLat(), serviceConfigure.getLng());
            if (configure == null) {
                log.warn("远程配置初始化失败, 启用本地配置");
                serviceConfigure.setLocalConfigure(true);
                serviceConfigure.channelAddresses.clear();
                for (String channel : serviceConfigure.getChannels()) {
                    if (!serviceConfigure.fallbackChannelAddresses.containsKey(channel)) {
                        log.error("远程配置初始化失败，并且通道'{}'本地配置无效，请检查配置！", channel);
                        if (!silent) {
                            throw new InitException("远程配置初始化失败，并且通道'" + channel + "'本地配置无效，请检查配置！");
                        } else {
                            asyncHandler.fail(InterfaceRspCode.INTERFACE_FALLBACK_GATEWAY_IS_NOT_CONFIG, "远程配置初始化失败，并且通道'" + channel + "'本地配置无效，请检查配置！");
                            return false;
                        }
                    }
                    GatewayAddress gatewayAddress = serviceConfigure.getFallbackGatewayAddresses(channel);
                    if (gatewayAddress.getSchema() == null || gatewayAddress.getHost() == null || gatewayAddress.getPort() == 0 || gatewayAddress.getContextPath() == null) {
                        if (!silent) {
                            throw new InitException("远程配置初始化失败，并且通道'" + channel + "'本地配置并未配置参数值，请检查配置！");
                        } else {
                            asyncHandler.fail(InterfaceRspCode.INTERFACE_FALLBACK_GATEWAY_IS_NOT_CONFIG, "远程配置初始化失败，并且通道'" + channel + "'本地配置并未配置参数值，请检查配置！");
                            return false;
                        }
                    }
                }
                return true;
            } else {
                log.debug("远程配置初始化成功, 启用远程配置");
                if (configure.isVerboseLog()) {
                    LoggerFactory.level(LoggerLevel.TRACE);
                } else if (configure.isDebug()) {
                    LoggerFactory.level(LoggerLevel.DEBUG);
                } else {
                    LoggerFactory.level(LoggerLevel.INFO);
                }
                serviceConfigure.setAutoLocate(configure.isAutoLocate());
                serviceConfigure.setKeyVector(configure.getKeyVector());
                serviceConfigure.setHttpConnectTimeoutSecond(configure.getHttpConnectTimeoutSecond());
                serviceConfigure.setHttpReadTimeoutSecond(configure.getHttpReadTimeoutSecond());
                serviceConfigure.setAutoLocate(configure.isAutoLocate());
                serviceConfigure.setAsyncExecuteThreadPoolSize(configure.getAsyncExecuteThreadPoolSize());
                serviceConfigure.setEnv(configure.getEnv());
                serviceConfigure.setEnvDesc(configure.getEnvDesc());
                //不进行自动定位时，使用模拟定位数据
                if (!serviceConfigure.isAutoLocate()) {
                    serviceConfigure.refreshLocation(new Location(Double.valueOf(StringUtils.safeToString(configure.getMockLng(), "0")), Double.valueOf(StringUtils.safeToString(configure.getMockLat(), "0"))));
                }
                //重设异步线程池
//                AsyncTask.setAsyncExecuteThreadPoolSize(configure.getAsyncExecuteThreadPoolSize());
                List<GatewayChannel> channels = configure.getChannels();
                log.debug("设置通道网关地址");
                serviceConfigure.channelAddresses.clear();
                for (GatewayChannel gatewayChannel : channels) {
                    serviceConfigure.channelAddresses.put(gatewayChannel.getChannel(), gatewayChannel.getGatewayAddresses());
                }
                log.debug("初始化线程池");
                return true;
            }
        }
    }

    /**
     * 进行初始化,将注册的服务类与接口信息进行绑定
     *
     * @return 是否执行失败成功
     */
    public synchronized final boolean init() {
        return init(false, null);
    }

    /**
     * 进行初始化,将注册的服务类与接口信息进行绑定
     *
     * @param silent       是否静默模式
     * @param asyncHandler 异步处理器
     * @return 是否成功
     */
    public synchronized final boolean init(final boolean silent, AsyncHandler asyncHandler) {
        if (silent && asyncHandler == null) {
            throw new InitException("静默模式下，必须传入AsyncHandler实例!");
        }
        Map<String, Set<InterfaceMetadata>> metadataMap = MetadataClassPathScanner.scan(serviceClasses);
        serviceConfigure.initChannels(metadataMap.keySet());
        for (Set<InterfaceMetadata> interfaceMetadataSet : metadataMap.values()) {
            for (InterfaceMetadata metadata : interfaceMetadataSet) {
                log.debug("register {}.{}-->{}:{}:{}", metadata.getInterfaceClass(), metadata.getInterfaceMethod(), metadata.getChannel(), metadata.getTxNo(), metadata.getVersion());
                metadataRegister.register(metadata);
            }
        }
        if (!fetchRemoteConfigure(silent, asyncHandler)) {
            return false;
        }
        if (fetchConfigureIntervalSecond > 0) {
            initScheduleFetchConfigure();
        }
        if (fetchMetadataIntervalSecond > 0) {
            initScheduleFetchMetadata();
        }
        String code = null;
        String desc = null;
        String data = null;
        if (!JavaEnvironmentDetector.isAndroid()) {
            PublishService publishService = ServiceProxyFactory.newInstance(this, PublishService.class);
            FetchPublishRequest request = new FetchPublishRequest();
            request.getChannels().addAll(serviceConfigure.getChannels());
            Future<ApiResponse> future = publishService.fetchPublish(request, new AsyncHandler<FetchPublishResponse>() {
                @Override
                public void fail(String code, String desc, String detail) {
                    log.debug("call publishService.fetchPublish happens error!  {}:{} cause :{} ", code, desc, detail);
                }

                @Override
                public void success(FetchPublishResponse response) {
                    definitionRegister.clear();
                    for (InterfaceChannel interfaceChannel : response.getChannels()) {
                        definitionRegister.register(interfaceChannel);
                    }
                    log.debug("finish fetch remote metadata...");
                }
            });
            ApiResponse result = null;
            try {
                result = future.get(serviceConfigure.getHttpReadTimeoutSecond() * 2, TimeUnit.SECONDS); //取得结果，同时设置超时执行时间为5秒。同样可以用future.get()，不设置执行超时时间取得结果
            } catch (Exception e) {
                log.error("获取元信息发生错误!");
                if (!silent) {
                    throw new InitException("获取元信息发生错误!");
                } else {
                    return false;
                }
            }
            if (result == null) {
                log.error("获取发布信息失败!");
                if (!silent) {
                    throw new InitException("获取发布信息失败!");
                } else {
                    return false;
                }
            }
            code = result.getCode();
            desc = result.getDesc();
            data = result.getData();
        } else {
            AndroidPublishService publishService = ServiceProxyFactory.newInstance(this, AndroidPublishService.class);
            FetchPublishRequest request = new FetchPublishRequest();
            request.getChannels().addAll(serviceConfigure.getChannels());
            android.os.AsyncTask<FetchPublishRequest, Void, ApiResponse> future = publishService.fetchPublish(request, new AsyncHandler<FetchPublishResponse>() {
                @Override
                public void fail(String code, String desc, String detail) {
                    log.debug("call publishService.fetchPublish happens error!  {}:{} cause :{} ", code, desc, detail);
                }

                @Override
                public void success(FetchPublishResponse response) {
                    definitionRegister.clear();
                    for (InterfaceChannel interfaceChannel : response.getChannels()) {
                        definitionRegister.register(interfaceChannel);
                    }
                    log.debug("finish fetch remote metadata...");
                }
            });
            ApiResponse result = null;
            try {
                result = future.get(serviceConfigure.getHttpReadTimeoutSecond() * 2, TimeUnit.SECONDS); //取得结果，同时设置超时执行时间为5秒。同样可以用future.get()，不设置执行超时时间取得结果
            } catch (Exception e) {
                log.error("获取元信息发生错误!");
                if (!silent) {
                    throw new InitException("获取元信息发生错误!");
                } else {
                    return false;
                }
            }
            if (result == null) {
                log.error("获取发布信息失败!");
                if (!silent) {
                    throw new InitException("获取发布信息失败!");
                } else {
                    return false;
                }
            }
            code = result.getCode();
            desc = result.getDesc();
            data = result.getData();
        }
        if (InterfaceRspCode.valueOfCode(code) != InterfaceRspCode.SUCCESS) {
            if (JavaEnvironmentDetector.isAndroid()) {
                if (InterfaceRspCode.TIMESTAMP_ILLEGAL.getCode().equals(code)) {
                    desc = "手机" + desc;
                }
            }
            log.error("{}:{}", code, desc);
            if (!silent) {
                throw new InitException(desc);
            } else {
                asyncHandler.fail(InterfaceRspCode.FAIL.getCode(), desc, desc);
                return false;
            }
        } else {
            FetchPublishResponse response = gson.fromJson(data, FetchPublishResponse.class);
            if ("0000".equals(response.getRspCode())) {
                init.set(true);
                if (asyncHandler != null) {
                    asyncHandler.success(response);
                }
                return true;
            } else {
                if (!silent) {
                    throw new InitException("获取接口元信息失败！");
                } else {
                    asyncHandler.fail(InterfaceRspCode.FETCH_INTERFACE_METADATA_IS_FAILURE, "获取接口元信息失败！");
                    return false;
                }
            }
        }
    }

    /**
     * 增加服务类接口
     *
     * @param serviceClasses 服务类接口数组
     */
    public final void addServiceClasses(Class... serviceClasses) {
        if (isInit()) {
            throw new InitException("已经初始化不允许添加服务");
        }
        for (Class serviceClass : serviceClasses) {
            this.serviceClasses.add(serviceClass);
            log.debug("add service class {}", serviceClass);
        }
    }

    /**
     * 扫描指定包路径下的服务接口
     *
     * @param basePackages 包路径数组
     */
    public final void scan(String... basePackages) {
        scan(true, basePackages);
    }

    /**
     * 扫描指定包路径下的服务接口
     *
     * @param subPackage   是否扫描子包
     * @param basePackages 包路径数组
     */
    public final void scan(boolean subPackage, String... basePackages) {
        if (isInit()) {
            throw new InitException("已经初始化不允许添加服务");
        }
        ClassScanner scanner = new ClassScanner(this.getClass().getClassLoader(), subPackage);
        for (String basePackage : basePackages) {
            scanner.scan(basePackage, new ClassScanner.AnnotatedWithFilter(ApidocService.class));
        }
        serviceClasses.addAll(scanner.getClasses());
    }

    /**
     * 将服务接口包装为服务实例，在发生系统异常时回调异步处理器
     *
     * @param serviceClass 服务类接口
     * @param asyncHandler 异步处理器
     * @param <T>          服务实例
     * @return 服务实例
     */
    public synchronized final <T> T get(Class<T> serviceClass, final AsyncHandler<Boolean> asyncHandler) {
        T stub = get(serviceClass);
        if (stub == null) {
            log.error("stub '{}' is not definition!", serviceClass);
            asyncHandler.fail(InterfaceRspCode.INTERFACE_IS_ILLEGAL, "获取服务失败");
        }
        return stub;
    }

    /**
     * 将服务接口包装为服务实例，在发生系统异常时抛出运行时异常
     *
     * @param serviceClass 服务类接口
     * @param <T>          服务实例
     * @return 服务实例
     */
    public synchronized final <T> T get(Class<T> serviceClass) {
        T stub = serviceRegister.lookup(serviceClass);
        if (stub == null) {
            stub = ServiceProxyFactory.newInstance(this, serviceClass);
            serviceRegister.register(serviceClass, stub);
        }
        log.debug("get '{}' stub instance ", serviceClass);
        return stub;
    }

    /**
     * 获取接口连接器实例
     *
     * @return 连接器实例
     */
    public InterfaceConnector getInterfaceConnector() {
        if (interfaceConnector == null) {
            try {
                Constructor constructor = serviceConfigure.interfaceConnectorClass.getConstructor(ServiceFactory.class);
                interfaceConnector = (InterfaceConnector) constructor.newInstance(this);
            } catch (Exception e) {

            }
        }
        log.debug("get Interface Connector {}", serviceConfigure.interfaceConnectorClass);
        return interfaceConnector;
    }

    /**
     * 调用定位信息提供者进行定位
     */
    public void refreshLocation() {
        if (locationProvider == null) {
            throw new LocationProviderNotFoundException("location provider is not found!");
        }
        locationProvider.locate(serviceConfigure);
    }

    class FetchConfigureTask implements Runnable {
        @Override
        public void run() {
            //调用拉取远程配置
            try {
                fetchRemoteConfigure(false, null);
            } catch (Exception e) {
                log.error("fetch Remote Configure happens error!", e);
            }
        }
    }

    class FetchMetadataTask implements Runnable {
        @Override
        public void run() {
            try {
                PublishService publishService = ServiceProxyFactory.newInstance(ServiceFactory.this, PublishService.class);
                FetchPublishRequest request = new FetchPublishRequest();
                request.getChannels().addAll(serviceConfigure.getChannels());
                publishService.fetchPublish(request, new AsyncHandler<FetchPublishResponse>() {
                    @Override
                    public void fail(String code, String desc, String detail) {
                        log.debug("call publishService.fetchPublish happens error!  {}:{} cause :{} ", code, desc, detail);
                    }

                    @Override
                    public void success(FetchPublishResponse response) {
                        definitionRegister.clear();
                        for (InterfaceChannel interfaceChannel : response.getChannels()) {
                            definitionRegister.register(interfaceChannel);
                        }
                        log.debug("finish fetch remote metadata...");
                    }
                });
            } catch (Exception e) {
                log.error("fetch metadata happens error!", e);
            }
        }
    }

    /**
     * 初始化拉取远程配置定时任务
     */
    void initScheduleFetchConfigure() {
        scheduleExecutor.scheduleWithFixedDelay(new FetchConfigureTask(), fetchConfigureIntervalSecond, fetchConfigureIntervalSecond, TimeUnit.SECONDS);
    }

    /**
     * 初始化拉取接口元信息
     */
    void initScheduleFetchMetadata() {
        scheduleExecutor.scheduleWithFixedDelay(new FetchMetadataTask(), fetchMetadataIntervalSecond, fetchMetadataIntervalSecond, TimeUnit.SECONDS);
    }

    //-----------------------------------服务工厂单例对象-----------------------------------------------
    private static final ServiceFactory INSTANCE = new ServiceFactory();

    /**
     * 新建一个服务工厂对象
     *
     * @return 服务工厂对象
     */
    public final static ServiceFactory newInstance() {
        return new ServiceFactory();
    }

    /**
     * 获取服务工厂的单例对象
     *
     * @return 服务工厂对象
     */
    public final static ServiceFactory getInstance() {
        return INSTANCE;
    }
}
